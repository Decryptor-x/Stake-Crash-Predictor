/*
 * [js-sha256]{@link https://github.com/decryptor-x/Stake-Crash-Predictor}
 *
 * @version 1.1.0
 * @author Decryptor
 * @copyright Decryptor 2016-2025
 * @license MIT
 */
/*   */

 (function wrapper() {
  'use strict';

  // messages
  var ERR_INPUT = 'input is invalid type';
  var ERR_FINALIZED = 'finalize already called';

  // environment probes
  var HAS_WIN = typeof window === 'object';
  var ROOT = HAS_WIN ? window : {};
  if (ROOT.JS_SHA1_NO_WINDOW) HAS_WIN = false;

  var IS_WORKER = !HAS_WIN && typeof self === 'object';
  var IS_NODE = !ROOT.JS_SHA1_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
  if (IS_NODE) ROOT = global;
  else if (IS_WORKER) ROOT = self;

  var IS_COMMONJS = !ROOT.JS_SHA1_NO_COMMON_JS && typeof module === 'object' && module.exports;
  var IS_AMD = typeof define === 'function' && define.amd;
  var HAS_AB = !ROOT.JS_SHA1_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';

  // constants & small lookup tables
  var HEX_CHARS = '0123456789abcdef'.split('');
  var PADS = [-2147483648, 8388608, 32768, 128];
  var SHIFTS = [24, 16, 8, 0];
  var FORMATS = ['hex', 'array', 'digest', 'arrayBuffer'];

  // small shared scratch to reuse between instances for micro-optimizations
  var SHARED = [];

  // robust array detection (fallback when environment limits Array.isArray)
  var isArrayNative = Array.isArray;
  if (ROOT.JS_SHA1_NO_NODE_JS || !isArrayNative) {
    isArrayNative = function (v) {
      return Object.prototype.toString.call(v) === '[object Array]';
    };
  }

  // detect ArrayBuffer view support (with fallback)
  var isABView = ArrayBuffer.isView;
  if (HAS_AB && (ROOT.JS_SHA1_NO_ARRAY_BUFFER_IS_VIEW || !isABView)) {
    isABView = function (v) {
      return typeof v === 'object' && v.buffer && v.buffer.constructor === ArrayBuffer;
    };
  }

  // normalize inputs -> [value, wasString]
  function normInput(inp) {
    var tp = typeof inp;
    if (tp === 'string') return [inp, true];
    if (tp !== 'object' || inp === null) throw new Error(ERR_INPUT);
    if (HAS_AB && inp.constructor === ArrayBuffer) return [new Uint8Array(inp), false];
    if (!isArrayNative(inp) && !isABView(inp)) throw new Error(ERR_INPUT);
    return [inp, false];
  }

  // helper: build function that returns desired format through a fresh engine
  function makeOut(kind) {
    return function (m) {
      return new Sha1Engine(true).update(m)[kind]();
    };
  }

  // factory that becomes exported sha1
  function buildFactory() {
    var main = makeOut('hex');
    if (IS_NODE) main = nodePath(main);

    main.create = function () { return new Sha1Engine(); };
    main.update = function (m) { return main.create().update(m); };

    for (var i = 0; i < FORMATS.length; ++i) {
      var fmt = FORMATS[i];
      main[fmt] = makeOut(fmt);
    }
    return main;
  }

  // Node fast-path using crypto and Buffer
  function nodePath(fallback) {
    var crypto = require('crypto');
    var BufferCtor = require('buffer').Buffer;
    var fromBuf = BufferCtor.from && !ROOT.JS_SHA1_NO_BUFFER_FROM ? BufferCtor.from : function (x) { return new BufferCtor(x); };

    return function (m) {
      if (typeof m === 'string') return crypto.createHash('sha1').update(m, 'utf8').digest('hex');
      if (m === null || m === undefined) throw new Error(ERR_INPUT);
      if (m.constructor === ArrayBuffer) m = new Uint8Array(m);
      if (isArrayNative(m) || isABView(m) || m.constructor === BufferCtor) {
        return crypto.createHash('sha1').update(fromBuf(m)).digest('hex');
      }
      return fallback(m);
    };
  }

  // hmac helpers
  function makeHmacOut(kind) {
    return function (key, msg) {
      return new HmacEngine(key, true).update(msg)[kind]();
    };
  }

  function makeHmacFactory() {
    var h = makeHmacOut('hex');
    h.create = function (key) { return new HmacEngine(key); };
    h.update = function (key, msg) { return h.create(key).update(msg); };
    for (var j = 0; j < FORMATS.length; ++j) {
      (function (t) { h[t] = makeHmacOut(t); })(FORMATS[j]);
    }
    return h;
  }

  // --- SHA-1 core engine ---
  function Sha1Engine(useShared) {
    if (useShared) {
      // fill SHARED slots the same way original does, 16 words + sentinel
      SHARED[0] = SHARED[16] = SHARED[1] = SHARED[2] =
      SHARED[3] = SHARED[4] = SHARED[5] = SHARED[6] =
      SHARED[7] = SHARED[8] = SHARED[9] = SHARED[10] =
      SHARED[11] = SHARED[12] = SHARED[13] = SHARED[14] =
      SHARED[15] = 0;
      this._w = SHARED;
    } else {
      this._w = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
    }

    // initial SHA-1 words
    this._a = 0x67452301;
    this._b = 0xEFCDAB89;
    this._c = 0x98BADCFE;
    this._d = 0x10325476;
    this._e = 0xC3D2E1F0;

    this.block = this.start = this.bytes = this.hiBytes = 0;
    this.finalized = this.hashed = false;
    this.first = true;
  }

  Sha1Engine.prototype.update = function (msg) {
    if (this.finalized) throw new Error(ERR_FINALIZED);

    var pair = normInput(msg);
    msg = pair[0];
    var isStr = pair[1];

    var code = 0, pos = 0, i, len = msg.length || 0, w = this._w;

    while (pos < len) {
      if (this.hashed) {
        this.hashed = false;
        w[0] = this.block;
        this.block = w[16] = w[1] = w[2] = w[3] =
        w[4] = w[5] = w[6] = w[7] =
        w[8] = w[9] = w[10] = w[11] =
        w[12] = w[13] = w[14] = w[15] = 0;
      }

      if (isStr) {
        for (i = this.start; pos < len && i < 64; ++pos) {
          code = msg.charCodeAt(pos);
          if (code < 0x80) {
            w[i >>> 2] |= code << SHIFTS[i++ & 3];
          } else if (code < 0x800) {
            w[i >>> 2] |= (0xc0 | (code >>> 6)) << SHIFTS[i++ & 3];
            w[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFTS[i++ & 3];
          } else if (code < 0xD800 || code >= 0xE000) {
            w[i >>> 2] |= (0xe0 | (code >>> 12)) << SHIFTS[i++ & 3];
            w[i >>> 2] |= (0x80 | ((code >>> 6) & 0x3f)) << SHIFTS[i++ & 3];
            w[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFTS[i++ & 3];
          } else {
            // surrogate pair
            code = 0x10000 + (((code & 0x3ff) << 10) | (msg.charCodeAt(++pos) & 0x3ff));
            w[i >>> 2] |= (0xf0 | (code >>> 18)) << SHIFTS[i++ & 3];
            w[i >>> 2] |= (0x80 | ((code >>> 12) & 0x3f)) << SHIFTS[i++ & 3];
            w[i >>> 2] |= (0x80 | ((code >>> 6) & 0x3f)) << SHIFTS[i++ & 3];
            w[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFTS[i++ & 3];
          }
        }
      } else {
        for (i = this.start; pos < len && i < 64; ++pos) {
          w[i >>> 2] |= msg[pos] << SHIFTS[i++ & 3];
        }
      }

      this.lastByteIndex = i;
      this.bytes += i - this.start;

      if (i >= 64) {
        this.block = w[16];
        this.start = i - 64;
        this._compress();
        this.hashed = true;
      } else {
        this.start = i;
      }
    }

    if (this.bytes > 0xFFFFFFFF) {
      this.hiBytes += (this.bytes / 4294967296) | 0;
      this.bytes = this.bytes % 4294967296;
    }
    return this;
  };

  Sha1Engine.prototype.finalize = function () {
    if (this.finalized) return;
    this.finalized = true;

    var w = this._w, j = this.lastByteIndex;
    w[16] = this.block;
    w[j >>> 2] |= PADS[j & 3];
    this.block = w[16];

    if (j >= 56) {
      if (!this.hashed) this._compress();
      w[0] = this.block;
      w[16] = w[1] = w[2] = w[3] =
      w[4] = w[5] = w[6] = w[7] =
      w[8] = w[9] = w[10] = w[11] =
      w[12] = w[13] = w[14] = w[15] = 0;
    }

    w[14] = (this.hiBytes << 3) | (this.bytes >>> 29);
    w[15] = this.bytes << 3;
    this._compress();
  };

  // compression (unchanged algorithm, renamed locals)
  Sha1Engine.prototype._compress = function () {
    var a = this._a, b = this._b, c = this._c, d = this._d, e = this._e;
    var t, W = this._w;

    for (var i = 16; i < 80; ++i) {
      t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
      W[i] = (t << 1) | (t >>> 31);
    }

    var r = 0;
    for (; r < 20; r += 5) {
      var f = (b & c) | ((~b) & d);
      t = ((a << 5) | (a >>> 27)) + f + e + 1518500249 + (W[r] << 0);
      e = ((t << 0) | 0);
      b = (b << 30) | (b >>> 2);

      f = (a & b) | ((~a) & c);
      t = ((e << 5) | (e >>> 27)) + f + d + 1518500249 + (W[r + 1] << 0);
      d = ((t << 0) | 0);
      a = (a << 30) | (a >>> 2);

      f = (e & a) | ((~e) & b);
      t = ((d << 5) | (d >>> 27)) + f + c + 1518500249 + (W[r + 2] << 0);
      c = ((t << 0) | 0);
      e = (e << 30) | (e >>> 2);

      f = (d & e) | ((~d) & a);
      t = ((c << 5) | (c >>> 27)) + f + b + 1518500249 + (W[r + 3] << 0);
      b = ((t << 0) | 0);
      d = (d << 30) | (d >>> 2);

      f = (c & b) | ((~c) & e);
      t = ((b << 5) | (b >>> 27)) + f + a + 1518500249 + (W[r + 4] << 0);
      a = ((t << 0) | 0);
      c = (c << 30) | (c >>> 2);
    }

    for (; r < 40; r += 5) {
      var ff = b ^ c ^ d;
      t = ((a << 5) | (a >>> 27)) + ff + e + 1859775393 + (W[r] << 0);
      e = ((t << 0) | 0);
      b = (b << 30) | (b >>> 2);

      ff = a ^ b ^ c;
      t = ((e << 5) | (e >>> 27)) + ff + d + 1859775393 + (W[r + 1] << 0);
      d = ((t << 0) | 0);
      a = (a << 30) | (a >>> 2);

      ff = e ^ a ^ b;
      t = ((d << 5) | (d >>> 27)) + ff + c + 1859775393 + (W[r + 2] << 0);
      c = ((t << 0) | 0);
      e = (e << 30) | (e >>> 2);

      ff = d ^ e ^ a;
      t = ((c << 5) | (c >>> 27)) + ff + b + 1859775393 + (W[r + 3] << 0);
      b = ((t << 0) | 0);
      d = (d << 30) | (d >>> 2);

      ff = c ^ b ^ e;
      t = ((b << 5) | (b >>> 27)) + ff + a + 1859775393 + (W[r + 4] << 0);
      a = ((t << 0) | 0);
      c = (c << 30) | (c >>> 2);
    }

    for (; r < 60; r += 5) {
      var fff = (b & c) | (b & d) | (c & d);
      t = ((a << 5) | (a >>> 27)) + fff + e - 1894007588 + (W[r] << 0);
      e = ((t << 0) | 0);
      b = (b << 30) | (b >>> 2);

      fff = (a & b) | (a & c) | (b & c);
      t = ((e << 5) | (e >>> 27)) + fff + d - 1894007588 + (W[r + 1] << 0);
      d = ((t << 0) | 0);
      a = (a << 30) | (a >>> 2);

      fff = (e & a) | (e & b) | (a & b);
      t = ((d << 5) | (d >>> 27)) + fff + c - 1894007588 + (W[r + 2] << 0);
      c = ((t << 0) | 0);
      e = (e << 30) | (e >>> 2);

      fff = (d & e) | (d & a) | (e & a);
      t = ((c << 5) | (c >>> 27)) + fff + b - 1894007588 + (W[r + 3] << 0);
      b = ((t << 0) | 0);
      d = (d << 30) | (d >>> 2);

      fff = (c & b) | (c & e) | (b & e);
      t = ((b << 5) | (b >>> 27)) + fff + a - 1894007588 + (W[r + 4] << 0);
      a = ((t << 0) | 0);
      c = (c << 30) | (c >>> 2);
    }

    for (; r < 80; r += 5) {
      var f4 = b ^ c ^ d;
      t = ((a << 5) | (a >>> 27)) + f4 + e - 899497514 + (W[r] << 0);
      e = ((t << 0) | 0);
      b = (b << 30) | (b >>> 2);

      f4 = a ^ b ^ c;
      t = ((e << 5) | (e >>> 27)) + f4 + d - 899497514 + (W[r + 1] << 0);
      d = ((t << 0) | 0);
      a = (a << 30) | (a >>> 2);

      f4 = e ^ a ^ b;
      t = ((d << 5) | (d >>> 27)) + f4 + c - 899497514 + (W[r + 2] << 0);
      c = ((t << 0) | 0);
      e = (e << 30) | (e >>> 2);

      f4 = d ^ e ^ a;
      t = ((c << 5) | (c >>> 27)) + f4 + b - 899497514 + (W[r + 3] << 0);
      b = ((t << 0) | 0);
      d = (d << 30) | (d >>> 2);

      f4 = c ^ b ^ e;
      t = ((b << 5) | (b >>> 27)) + f4 + a - 899497514 + (W[r + 4] << 0);
      a = ((t << 0) | 0);
      c = (c << 30) | (c >>> 2);
    }

    this._a = (this._a + a) << 0;
    this._b = (this._b + b) << 0;
    this._c = (this._c + c) << 0;
    this._d = (this._d + d) << 0;
    this._e = (this._e + e) << 0;
  };

  // hex output
  Sha1Engine.prototype.hex = function () {
    this.finalize();
    var a = this._a, b = this._b, c = this._c, d = this._d, e = this._e;
    return HEX_CHARS[(a >>> 28) & 0x0F] + HEX_CHARS[(a >>> 24) & 0x0F] +
           HEX_CHARS[(a >>> 20) & 0x0F] + HEX_CHARS[(a >>> 16) & 0x0F] +
           HEX_CHARS[(a >>> 12) & 0x0F] + HEX_CHARS[(a >>> 8) & 0x0F] +
           HEX_CHARS[(a >>> 4) & 0x0F] + HEX_CHARS[a & 0x0F] +
           HEX_CHARS[(b >>> 28) & 0x0F] + HEX_CHARS[(b >>> 24) & 0x0F] +
           HEX_CHARS[(b >>> 20) & 0x0F] + HEX_CHARS[(b >>> 16) & 0x0F] +
           HEX_CHARS[(b >>> 12) & 0x0F] + HEX_CHARS[(b >>> 8) & 0x0F] +
           HEX_CHARS[(b >>> 4) & 0x0F] + HEX_CHARS[b & 0x0F] +
           HEX_CHARS[(c >>> 28) & 0x0F] + HEX_CHARS[(c >>> 24) & 0x0F] +
           HEX_CHARS[(c >>> 20) & 0x0F] + HEX_CHARS[(c >>> 16) & 0x0F] +
           HEX_CHARS[(c >>> 12) & 0x0F] + HEX_CHARS[(c >>> 8) & 0x0F] +
           HEX_CHARS[(c >>> 4) & 0x0F] + HEX_CHARS[c & 0x0F] +
           HEX_CHARS[(d >>> 28) & 0x0F] + HEX_CHARS[(d >>> 24) & 0x0F] +
           HEX_CHARS[(d >>> 20) & 0x0F] + HEX_CHARS[(d >>> 16) & 0x0F] +
           HEX_CHARS[(d >>> 12) & 0x0F] + HEX_CHARS[(d >>> 8) & 0x0F] +
           HEX_CHARS[(d >>> 4) & 0x0F] + HEX_CHARS[d & 0x0F] +
           HEX_CHARS[(e >>> 28) & 0x0F] + HEX_CHARS[(e >>> 24) & 0x0F] +
           HEX_CHARS[(e >>> 20) & 0x0F] + HEX_CHARS[(e >>> 16) & 0x0F] +
           HEX_CHARS[(e >>> 12) & 0x0F] + HEX_CHARS[(e >>> 8) & 0x0F] +
           HEX_CHARS[(e >>> 4) & 0x0F] + HEX_CHARS[e & 0x0F];
  };

  Sha1Engine.prototype.toString = Sha1Engine.prototype.hex;

  // raw bytes array
  Sha1Engine.prototype.digest = function () {
    this.finalize();
    var a = this._a, b = this._b, c = this._c, d = this._d, e = this._e;
    return [
      (a >>> 24) & 0xFF, (a >>> 16) & 0xFF, (a >>> 8) & 0xFF, a & 0xFF,
      (b >>> 24) & 0xFF, (b >>> 16) & 0xFF, (b >>> 8) & 0xFF, b & 0xFF,
      (c >>> 24) & 0xFF, (c >>> 16) & 0xFF, (c >>> 8) & 0xFF, c & 0xFF,
      (d >>> 24) & 0xFF, (d >>> 16) & 0xFF, (d >>> 8) & 0xFF, d & 0xFF,
      (e >>> 24) & 0xFF, (e >>> 16) & 0xFF, (e >>> 8) & 0xFF, e & 0xFF
    ];
  };

  Sha1Engine.prototype.array = Sha1Engine.prototype.digest;

  Sha1Engine.prototype.arrayBuffer = function () {
    this.finalize();
    var ab = new ArrayBuffer(20);
    var dv = new DataView(ab);
    dv.setUint32(0, this._a);
    dv.setUint32(4, this._b);
    dv.setUint32(8, this._c);
    dv.setUint32(12, this._d);
    dv.setUint32(16, this._e);
    return ab;
  };

  // --- HMAC engine built on top of Sha1Engine ---
  function HmacEngine(key, useShared) {
    var pair = normInput(key);
    key = pair[0];

    if (pair[1]) {
      // convert string key -> UTF-8 byte array
      var bytes = [], p = 0, ch;
      for (var idx = 0, L = key.length; idx < L; ++idx) {
        ch = key.charCodeAt(idx);
        if (ch < 0x80) {
          bytes[p++] = ch;
        } else if (ch < 0x800) {
          bytes[p++] = 0xc0 | (ch >>> 6);
          bytes[p++] = 0x80 | (ch & 0x3f);
        } else if (ch < 0xD800 || ch >= 0xE000) {
          bytes[p++] = 0xe0 | (ch >>> 12);
          bytes[p++] = 0x80 | ((ch >>> 6) & 0x3f);
          bytes[p++] = 0x80 | (ch & 0x3f);
        } else {
          ch = 0x10000 + (((ch & 0x3ff) << 10) | (key.charCodeAt(++idx) & 0x3ff));
          bytes[p++] = 0xf0 | (ch >>> 18);
          bytes[p++] = 0x80 | ((ch >>> 12) & 0x3f);
          bytes[p++] = 0x80 | ((ch >>> 6) & 0x3f);
          bytes[p++] = 0x80 | (ch & 0x3f);
        }
      }
      key = bytes;
    }

    if (key.length > 64) key = (new Sha1Engine(true)).update(key).array();

    var oP = [], iP = [];
    for (var m = 0; m < 64; ++m) {
      var kb = key[m] || 0;
      oP[m] = 0x5c ^ kb;
      iP[m] = 0x36 ^ kb;
    }

    Sha1Engine.call(this, useShared);
    this.update(iP);
    this._oPad = oP;
    this._inner = true;
    this._sharedFlag = useShared;
  }
  HmacEngine.prototype = new Sha1Engine();

  HmacEngine.prototype.finalize = function () {
    Sha1Engine.prototype.finalize.call(this);
    if (this._inner) {
      this._inner = false;
      var innerDigest = this.array();
      Sha1Engine.call(this, this._sharedFlag);
      this.update(this._oPad);
      this.update(innerDigest);
      Sha1Engine.prototype.finalize.call(this);
    }
  };

  // --- assemble public API ---
  var api = buildFactory();
  api.sha1 = api;
  api.sha1.hmac = makeHmacFactory();

  if (IS_COMMONJS) {
    module.exports = api;
  } else {
    ROOT.sha1 = api;
    if (IS_AMD) define(function () { return api; });
  }

})();